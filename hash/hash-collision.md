# Hash Collision

## Hash Collision

해시 함수는 보통 입력의 범위(공역)보다 출력의 범위(치역)가 작으므로 서로 다른 입력값에도 동일한 값이 출력되는 경우도 존재한다. 이러한 경우를 '충돌'한다고 한다.

해시 충돌 처리에는 크게 두 가지 기법이 있다. 하나는 리스트의 각각의 해시를 연결리스트로 만드는 개별 체이닝(Separate Chaining) 방법이고, 다른 하나는 위치한 해시 중 비어있는 곳에 넣는 방식인 오픈 어드레싱(Open Addressing) 방법이다.

### Separate Chaining

<figure><img src="../.gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure>

해시 테이블의 기본 방식이기도 한 개별 체이닝(Separate Chaining)은 충돌 발생 시 그림과 같이 **연결 리스트로 연결하는 방식**이다.

<figure><img src="../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

Separate Chaining에서 각 배열의 인자는 인덱스가 같은 해시 버킷을 연결한 링크드 리스트의 첫 부분(head)이다.

### Open Addressing

<figure><img src="../.gitbook/assets/image (3) (1).png" alt=""><figcaption></figcaption></figure>

오픈 어드레싱(Open Addressing)이란 추가적인 메모리를 사용하는 Chaining 방식과 다르게 비어있는 해시 테이블의 공간을 활용하는 방법이다.&#x20;

충돌이 일어나면 테이블 공간 내에서 탐사를 통해 빈 공간을 찾아 해결하며, 이 때문에 개별 체이닝 방식과 달리, 모든 원소가 반드시 자신의 해시값과 일치하는 주소에 저장된다는 보장은 없다.

Open Addressing을 구현하기 위한 대표적인 방법으로는 3가지 방식이 존재한다.

1. Linear Probing: 현재의 버킷 index로부터 **고정 폭만큼씩 이동**하여 차례대로 검색해 비어 있는 버킷에 데이터를 저장한다.
2. Quadratic Probing: 해시의 저장순서 **폭을 제곱으로** 저장하는 방식이다. 예를 들어 처음 충돌이 발생한 경우에는 1^2만큼 이동하고 그 다음 계속 충돌이 발생하면 2^2, 3^2 칸씩 옮기는 방식이다.
3. Double Hashing Probing: **해시된 값을 한번 더 해싱**하여 해시의 규칙성을 없애버리는 방식이다. 해시된 값을 한번 더 해싱하여 새로운 주소를 할당하기 때문에 다른 방법들보다 많은 연산을 하게 된다.

그림은 가장 간단한 방식인 **선형 탐사 방식**이며 충돌이 발생할 경우 해당 위치부터 순차적으로 탐사를 하나씩 진행한다. **특정 위치가 선점되어 있으면 바로 그 다음 위치를 확인**하는 식이다. 이렇게 탐사를 진행하다가 비어 있는 공간을 발견하면 삽입하게 된다.

선형 탐사 방식은 구현 방법이 간단하면서도, 의외로 전체적인 성능이 좋은 편이기도 하다.



#### 데이터 삭제

Open Addressing에서 데이터를 삭제하면 삭제된 공간은 Dummy Space로 활용되는데, 그렇기 때문에 Hash Table을 재정리해주는 작업이 필요하다.

삭제된 공간에 Dummy Space를 추가해주지 않으면 조회 시 해당 데이터가 있는 곳까지 도달하지 못하게 될 수 있기 때문에 Dummy Space를 추가해서 연결을 해준다.



## Hash 충돌로 인한 성능 저하

<figure><img src="../.gitbook/assets/image (3) (2).png" alt=""><figcaption></figcaption></figure>

충돌로 인한 성능 저하를 막을 수 없다. 그림과 같이 **수용률이 일정량을 넘어서게 되면 저장/조회 성능이 모두 점점 떨어진다**.

### 성능 저하 해결법 1 : 리스트 자체의 크기를 키운 뒤 재배열

그래서 수용률이 일정량을 넘어가게 되는 경우에는 아예 리스트 자체의 크기를 키운 뒤에 재배열을 하는 방법을 사용한다. 다만, 이 과정 자체가 **상당히 비용이 많이 드는 과정**이라서 실시간으로 빠르게 처리해야 하는 환경에서는 무리가 있을 수 있다.

### 성능 저하 해결법 2 : 큰 리스트를 따로 하나 만들어서 조금씩 옮긴 후 기존 테이블 삭제

이럴 때는 큰 리스트를 하나 만들어서 적당한 타이밍에 몇 개씩 점진적으로 옮기다가 다 옮기면 기존의 테이블을 없애 확장하는 대안도 있다. 하지만 이 경우에는 **메모리를 훨씬 더 많이 사용**하게 된다.

### 성능 저하 해결법 3 : 해시 비트 수 늘리기

해시의 비트 수를 늘리는 방법도 있다. 항목 수가 적을 때에는 짧은(적은 비트 수) 해시와 작은 저장 공간을 사용하다가 충돌이 잦아지면 비트 수를 1비트 늘리고 저장공간도 2배로 늘린다. 그리고 항목을 점진적으로 확장된 공간으로 이전하게 함으로써 충돌을 줄일 수 있다. 이를 **Consistent hashing**이라고 하며 분산 데이터 베이스에서 데이터의 일관성을 유지하기 위해 사용되고 있다.

### 성능 저하 해결법 4 : 캐싱

해시 테이블에서 자주 사용하게 되는 데이터를 Cache에 적용하면 효율을 높일 수 있다. 자주 hit하게 되는 데이터를 캐시에서 바로 찾음으로써 해시 테이블의 성능을 향상시킬 수 있다.

Separate Chaining과 Open Addressing 두 방법 모두 Worst Case의 시간복잡도는 O(n)이다. 하지만 Open Addressing은 연속된 공간에 데이터를 저장하기 때문에 Separate Chaining에 비하여 캐시 효율이 높다. 따라서 데이터 개수가 충분히 적다면 Open Addressing이 Separate Chaining보다 더 성능이 좋다.&#x20;

하지만 배열의 크기가 커질수록(n 값이 커질수록) 캐시 효율이라는 Open Addressing의 장점은 사라진다. 배열의 크기가 커지면, L1, L2 캐시 적중률(hit ratio)이 낮아지기 때문이다.



<mark style="color:red;">자료를 기본적으로 정렬하지 않은 상태로 저장</mark>하기 때문에 정렬된 순서로 접근하는 것은 비용이 매우 많이 들며 순회를 하는 경우에도 무효한 값들이 많아 실제 데이터의 개수만 순회하는 것보다 더 많은 비용이 들게 된다. 그리고 부하의 임계점을 적으면 50%, 많아봐야 75% 정도로 잡기 때문에 실제 데이터의 양보다 메모리를 많이 쓰게 된다.

각 언어별 해시 테이블의 구현 방식은 다음과 같다.

| 언어     | 방식      |
| ------ | ------- |
| C++    | 개별 체이닝  |
| Java   | 개별 체이닝  |
| Go     | 개별 체이닝  |
| Ruby   | 오픈 어드레싱 |
| Python | 오픈 어드레싱 |



## Seperate Chaining vs Open Addressing

|                      | Seperate Chaining        | Open Addressing          |
| -------------------- | ------------------------ | ------------------------ |
| Hash Time Complexity | Average O(1), Worst O(n) | Average O(1), Worst O(n) |
| 저장 가능 개수             |                          |                          |



### 저장 가능 개수

메모리가 무한하다는 가정 하에 사실상 무한정 저장할 수 있는 체이닝 방식과 달리, 오픈 어드레싱 방식은 전체 슬롯의 개수 이상은 저장할 수 없다.
